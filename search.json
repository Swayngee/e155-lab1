[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog posts",
    "section": "",
    "text": "Below are blog posts that consist of all my reflections within E155! I also included some class notes for clarity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 0\n\n\nInitial reflection\n\n\n\n\n\nAug 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\nWeird software\n\n\n\n\n\nSep 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\n\n\n\nNov 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\n\n\n\n\n\n\nDec 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\n\n\n\n\n\n\nDec 3, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\n\n\n\n\n\n\nDec 4, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 portfolio",
    "section": "",
    "text": "Hello! My name is Drake Gonzales and I am a Junior Engineering major at Harvey Mudd College. I am interested in studying computer and electrical engineering, with a specific focus in Lithography. This website, created with Quarto, posseses all of my work that I have completed in E155 “Microprocessor System:Design & Application”\nDate created: 8/27/2025"
  },
  {
    "objectID": "posts/reflection1.html",
    "href": "posts/reflection1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Initial reaction to Lab 1 of Microp? It was alot. The code itself wasnt that bad, but the software we used to program the FPGA was just horrible. It took around 10 minutes to load each time, and when you finally were able to load it, it would not recognize your FPGA was plugged in unless you crashed the site 100 times.\nOnce you get past this leap, everything else was pretty easy. Questa ran as normal, and running the testbenches were pretty fun. The hardware itself was fun to solder, and overall put together. I had one mishap where a wire in my circuit was faulty, and it took me an hour to debug, but thats the engineering process. I put fourth a lot of effort into this lab having been doing it for aorund 18 hours. It was rewarding when it was finally completed and I updated all of the side specifications."
  },
  {
    "objectID": "labs/lab5.html#introduction",
    "href": "labs/lab5.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "labs/lab6.html#introduction",
    "href": "labs/lab6.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "labs/lab3.html#introduction",
    "href": "labs/lab3.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "labs/lab1.html#introduction",
    "href": "labs/lab1.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a development board incorporating an MCU, an FPGA, and LEDs was created as the platform for exploring embedded systems. A design was implemented on the FPGA to control a 7-segment LED display and three individual LEDs. Once this lab is completed, four switches will have the capability of displaying all hexadecimal digits on the 7-segment display, and will be able to control two other LED’s based on combinational logic. The third LED will be controlled by a High-Speed Oscillator (HSOSC) have have a blink frequency of 2.4Hz.\nThe design was developed using SystemVerilog, a hardware description language, and was tested using Intels Questa, a logic waveform simulator."
  },
  {
    "objectID": "labs/lab1.html#technical-documentation",
    "href": "labs/lab1.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\n\nEquations\nTo find the overall input current for the design the formula V-Vf-IR=0 was used. The knowns for this equation are Vin, which is 3.3V, Vf, which is 2.1V, and the resistance used was 162Ω based on how bright the light was. Using this, the current comes out to 7.41mA, which is the upperbound of acceptable current going into FPGA pins.\nNext, to be able to solve for the correct clock cycles to correctly toggle led[2], solve first for time by doing 1/F, which is 0.416 seconds for two toggles (on and off). Then divide this by 2 to get 1 toggle (on), which is 0.208 seconds. Finally, to solve for amount of cycles the equation is N = t(toggle)* frequency(clk). Solving for this, N comes out to be 10,000,000 cycles.\nBlock Diagram\n\n\n\nFigure 1: This block diagram shows the connection between the MCU, FPGA, and LEDs used in Lab 1.\n\n\nThe block diagram pictured above in Figure 1 displays the internal design of the components used in our FPGA and the 7-segment display. Within the FPGA is pictured an AND gate, an XOR gate, an HSOSC (used as a clock divider), and a combinational logic block used to light our LED’s.\nWiring Schematic\n\n\n\nFigure 2: This schematic shows the wiring and components between our dev board and the 7-segment display\n\n\nFigure 2 above pictures the electrical circuit related to the FPGA and the 7-segment display. It portrays both modules along with the pins used for each module, and the necessary switches, LED’s, and pull down resistors needed. All output LED’s used were connected to 162Ω resistors to limit the input current directed toward the FPGA."
  },
  {
    "objectID": "labs/lab1.html#results-and-discussion",
    "href": "labs/lab1.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design implemented onto the FPGA met the primary objective of this lab, which was to display hexadecimal digits on the 7-segment display and control three onboard LEDs. The design created was also very accurate in its ability to display all sixteen hexadecimal values clearly, with each digit easily distinguishable from the others. The timing performance was reliable, and no noticeable delays or glitches occurred during operation. Furthermore, all three LED’s responded correctly to the switch inputs which showed that the logic was implemented correctly on the FPGA.\n\nTestbench Simulation\nThe following simulations were run on Intel’s Questa. This was done to visually see the waveforms created as a result of the logic used. To complete this simulation, a testbench was created to run test vectors through the logic created. Every couple of clock cycles a new combination of switches will be ran through the logic to test accuracy. The testbench then records the clock, the inputs, the outputs, and the expected outputs based on the test vectors.\n7-segment Display Simulation\n\n\n\nFigure 3: Above pictures the waveforms corresponding to the combinational logic used for the 7-segment display\n\n\nAbove shows a successful simulation of our 7-segment display. Each output corresponds to the expected output which shows correct usage of combinational logic within out 7-segment module.\nLED Display Simulation\n\n\n\nFigure 4: Above pictures the waveforms corresponding to the logic used for flashing Led[0] and Led[1]\n\n\nAbove again shows a successful simulation but for the three LED’s. Each output again corresponds to the expected output which suggests that our LED’s will perform correctly when wired together. Not pictured above is Led[2], which was validated using an oscilliscope.\nTop Module Simulation\n\n\n\nFigure 5: Above pictures the waveforms corresponding to the top module for the implemented design\n\n\nAbove is the overall module from our implemented design. It shows both outputs, their expected values, and the input into our system. This simulation was another success based on our outputs and the expected outputs from our test vectors."
  },
  {
    "objectID": "labs/lab1.html#conclusion",
    "href": "labs/lab1.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design created successfully showed all hexadecimal digits on the 7-segment display, and blinked three LED’s based on four input switches. This lab was completed in 12 hours."
  },
  {
    "objectID": "labs/lab1.html#ai-prototype",
    "href": "labs/lab1.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nBelow is the code generated from Claude, an LLM specializing in programming.\nmodule led_blinker ( output logic led );\n// Internal oscillator clock signal\nlogic clk_48mhz;\n\n// Counter for frequency division\n// 48MHz / 2Hz = 24M counts per half period\n// Need 25 bits to count up to 24M (2^25 = 33.5M)\nlogic [24:0] counter;\n\n// LED state register\nlogic led_state;\n\n// Instantiate the internal high-frequency oscillator\n// HFOSC primitive for UP5K - runs at 48 MHz\nSB_HFOSC #(\n    .CLKHF_DIV(\"0b00\")  // No division, full 48 MHz\n) hfosc_inst (\n    .CLKHFPU(1'b1),     // Power up the oscillator\n    .CLKHFEN(1'b1),     // Enable the oscillator\n    .CLKHF(clk_48mhz)   // 48 MHz output clock\n);\n\n// Calculate the count needed for 2 Hz toggle (1 Hz blink)\n// 48,000,000 / 4 = 12,000,000 counts per quarter period\n// This gives us 2 Hz toggle rate (1 Hz visible blink)\nlocalparam logic [24:0] TOGGLE_COUNT = 25'd12_000_000;\n\n// Counter and LED control logic\nalways_ff @(posedge clk_48mhz) begin\n    if (counter &gt;= TOGGLE_COUNT - 1) begin\n        counter &lt;= '0;              // Reset counter using SystemVerilog syntax\n        led_state &lt;= ~led_state;    // Toggle LED state\n    end else begin\n        counter &lt;= counter + 1'b1;\n    end\nend\n\n// Output assignment\nassign led = led_state;\nendmodule\n\n\nCode Review\nThe output from the LLM from above is pretty sophisticated. It hosts the correct inputs and outputs, and the module initializes the HSOSC to blink a frequency of 2 Hz. The only problem that was encountered with the output from this LLM is that it did not get the correct clock High-Speed Oscillator library. The error can be seen below.\nINFO &lt;2043018&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab1/source/impl_1/Ailab1.sv(1,8-1,14) (VERI-1018) compiling module ‘AiLab1’ WARNING &lt;2043063&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab1/source/impl_1/Ailab1.sv(18,5-24,7) (VERI-1063) instantiating unknown module ‘SB_HFOSC’ Done: design load finished with (0) errors, and (4) warnings\nRadiant (the synthesizer) hosts a wide variety of libraries that pertain to different FPGA’s. Claude probably got confused on which library to use as a result. However, the overall logic generated by Claude flowed well and showed no errors on the synthesizer. Next time when using Claude, or any LLM, be sure to correctly outline which libraries to be used for each module."
  },
  {
    "objectID": "labs/lab1.html#references",
    "href": "labs/lab1.html#references",
    "title": "E155 portfolio",
    "section": "References",
    "text": "References\nClass website"
  },
  {
    "objectID": "labs/lab2.html#introduction",
    "href": "labs/lab2.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a time-multiplexing scheme was made to drive two 7-segment display using single set of FPGA I/O pins. Time multiplexing is a technique in computer hardware that basically allows the use to use multiple purposes of a specific hardware at different times. In the case of this lab, time-multiplexing is used by displaying hexidecimal digits on the 7-segement display. The catch is, the display has two digital displays, but is controled by only one set of FPGA pins. Since both digits cannot be displayed at the same time, each digit is flickered to the point to where it appears each are both on at the same time. While this display is in place, five leds on a breadboard will display the addition of the hexadecimal digits displayed.\nThe design was developed using SystemVerilog, a hardware description language, and was tested using Intels Questa, a logic waveform simulator."
  },
  {
    "objectID": "labs/lab2.html#technical-documentation",
    "href": "labs/lab2.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\n\nEquations\nTo be able to solve for the correct clock cycles to correctly see both digits, first use a frequency in which the human cannot see flickering. This was guessed at around 240 Hz. Then do 1/F to get time = 0.00416 seconds. Then divide this by 2 to get 1 toggle (on), which is 0.002083 seconds. Finally, to solve for amount of cycles the equation is N = t(toggle)* frequency(clk). Solving for this, N comes out to be 100,000 cycles. Note** For testing of the HSOSC I used a frequency of 2.4 Mhz to be able to see the displays clearly toggling in the simulation.\nTo find the current at the transistor we first find the Base-Emitter Saturation Voltage, which is ~ 0.90. We then use V=IR in which V = (3.3V - 0.90) and R = 1kΩ. We then divide 2.4V / 1kΩ to get current. Our current comes out to be 2.4mA which is an acceptable current and it worked when implemented.\nThirdly, to find the overall input current for the 7-segment display, the formula V-Vd-IR=0 was used. The knowns for this equation are Vin, which is 3.3V, Vf, which is around 0.7V -0.25V (the Collector-Emmiter saturation), and the resistance used was 1kΩ based on how bright the light was. Using this, the current comes out to 2.35 mA, which is an acceptable current.\nLastly, for the leds we use current-limiting resistors. To solve for the current we use the same formula from above in which V-Vd-IR=0. The input current is 3.3V, Vd (drop) is around 2.2V. For the resistance, we chose a acceptable value such that our leds will still be bright for the lab. Thus we do 3.3V- 2.2V = 1.1V. Then we divide this by 330Ω to get 2.9mA, which is an acceptable current.\nBlock Diagram\n\n\n\nFigure 1: This block diagram shows the connection between the FPGA, its inside hardware, and LEDs used in Lab 2.\n\n\nThe block diagram above hosts the FPGA, a mux, a HSOSC module, and an output for the LED adder module. The input to this whole system is two input switches, s1 and s2, and three outputs, which were the display output, the binary 7-segment output, and the five Led adder output.\nWiring Schematic\n\n\n\nFigure 2: This schematic shows the wiring and components between our dev board, the 7-segment display, and our Led’s\n\n\nFigure 2 above pictures the electrical circuit related to the FPGA and the 7-segment display. It portrays both modules along with the pins used for each module, and the necessary switches, LED’s, pull down resistors, and transistors needed."
  },
  {
    "objectID": "labs/lab2.html#results-and-discussion",
    "href": "labs/lab2.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design implemented onto the FPGA met the primary objective of this lab, which was to display two hexadecimal digits on a two-sided 7-segment display and control five LED’s for an adder. This design was succsessfull in the way it that each Hexadecimal digits were clearly displayed at the ‘same time’, and the sum of these numbers was displayed on our led[4:0]. Furthermore, each segment on the 7-segment display appeared the same brightness, which suggests that the transistors and other electrical components worked as intended, and the sum of our numbers from the adder was correct.\n\nTestbench Simulation\nThe following simulations were run on Intel’s Questa. This was done to visually see the waveforms created as a result of the logic used. To complete this simulation, a testbench was created to run test vectors through the logic created. Each testbench below was written different.\nFor the 7-segment design, a testvector file was created to run through all possible switch inputs and outputs to our 7-segment display.\nSecondly, for the adder design, a for loop was created to run through all 256 possible testvectors possible. On the rising edge of the clock each testvector is ran through our .sv file, while on the falling edge, a test is ran to ensure that the sum is the expected value.\nThirdly, for our mux design, it displayed the same idea as the adder design, however there was no addition going into the for loop, and it checked if our enabler worked correctly.\nFinally, our top design held three test, each with different switch combinations, that tested whether the outputs match our expected outputs after it is ran through our module files.\n7-segment Display Simulation\n\n\n\nFigure 3: Above pictures the waveforms corresponding to the combinational logic used for the 7-segment display\n\n\nAbove is waveform simulation for the the 7-segment display design. This design was purely combinational logic, and hosts a clk and reset. This simulation was a success due to seg matching segexpected.\nLED Display Simulation\n\n\n\nFigure 4: Above pictures the waveforms corresponding to the logic used for flashing Led[4:0]\n\n\nFigure 4 shows the successfull simulation coming from the LED adder. The decimal values stemming from led and ledexpected are the same which shows that the leds will display the same behavior when connected to our FPGA.\nMux Simulation \nFigure 5 shows the simulation of the mux that has inputs of switches and the enabler. This simulation was a success based upon the fact that the output [mux] chnages based on which disp output was high.\nTop Module Simulation\n\n\n\nFigure 6: Above pictures the waveforms corresponding to the top module\n\n\nAbove is the top module design for the lab. It hosts inputs of reset and switches, and has outputs displ, led[4:0], seg[6:0]. To test the clock divider, a 2.5Mhz frequency was ran through the simulation. To test if this was done correct, we check if each of the sub-modules were performed correctly, then checked if, on the rising and falling edge of the clock, the clock divider changed, along with the disp, and mux outputs."
  },
  {
    "objectID": "labs/lab2.html#conclusion",
    "href": "labs/lab2.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design created was a successs. With each segment on the 7-segment display illuminating at the correct frequency, each transistor operating as intended, each led adding correctly, and each switch wired correctly. This lab was completed in 8 hours."
  },
  {
    "objectID": "labs/lab2.html#suggestions",
    "href": "labs/lab2.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nWhen first creating the modular design, keep the HSOSC at the top module level such that overall module testing is easier. Use a clk to test the HSOSC for a set frequency to be able to see correct toggling."
  },
  {
    "objectID": "labs/lab2.html#ai-prototype",
    "href": "labs/lab2.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai prototype",
    "text": "Ai prototype\n\nBelow is the output from Claude Ai after running this prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n// Time Multiplexed Seven Segment Decoder // Multiplexes a single decoder to drive two common anode displays\nmodule seven_seg_mux ( input logic clk, input logic rst_n, input logic [3:0] digit0_in, // First 4-bit input input logic [3:0] digit1_in, // Second 4-bit input output logic [6:0] seg0_out, // Seven segments for display 0 (active low) output logic [6:0] seg1_out, // Seven segments for display 1 (active low) output logic [1:0] display_sel // Display selection for external digit enable );\n// Internal signals\nlogic [3:0] mux_input;\nlogic [6:0] decoder_output;\nlogic mux_sel;\nlogic [15:0] counter;  // Counter for time multiplexing\n\n// Counter for generating multiplex timing\n// Adjust counter width and compare value for desired refresh rate\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter &lt;= 16'h0;\n    else\n        counter &lt;= counter + 1;\nend\n\n// Generate multiplex select signal\n// Toggle every 2^15 clock cycles (adjust as needed)\nassign mux_sel = counter[15];\nassign display_sel = {~mux_sel, mux_sel}; // One-hot display enable\n\n// Input multiplexer\nalways_comb begin\n    case (mux_sel)\n        1'b0: mux_input = digit0_in;\n        1'b1: mux_input = digit1_in;\n    endcase\nend\n\n// Seven segment decoder (common anode - active low outputs)\nalways_comb begin\n    case (mux_input)\n        4'h0: decoder_output = 7'b1000000; // 0\n        4'h1: decoder_output = 7'b1111001; // 1\n        4'h2: decoder_output = 7'b0100100; // 2\n        4'h3: decoder_output = 7'b0110000; // 3\n        4'h4: decoder_output = 7'b0011001; // 4\n        4'h5: decoder_output = 7'b0010010; // 5\n        4'h6: decoder_output = 7'b0000010; // 6\n        4'h7: decoder_output = 7'b1111000; // 7\n        4'h8: decoder_output = 7'b0000000; // 8\n        4'h9: decoder_output = 7'b0010000; // 9\n        4'hA: decoder_output = 7'b0001000; // A\n        4'hB: decoder_output = 7'b0000011; // b\n        4'hC: decoder_output = 7'b1000110; // C\n        4'hD: decoder_output = 7'b0100001; // d\n        4'hE: decoder_output = 7'b0000110; // E\n        4'hF: decoder_output = 7'b0001110; // F\n    endcase\nend\n\n// Output demultiplexer - route decoder output to appropriate display\nalways_comb begin\n    if (mux_sel == 1'b0) begin\n        seg0_out = decoder_output;\n        seg1_out = 7'b1111111;  // All segments off (active low)\n    end else begin\n        seg0_out = 7'b1111111;  // All segments off (active low)\n        seg1_out = decoder_output;\n    end\nend\nendmodule\n// Testbench module seven_seg_mux_tb; logic clk; logic rst_n; logic [3:0] digit0_in; logic [3:0] digit1_in; logic [6:0] seg0_out; logic [6:0] seg1_out; logic [1:0] display_sel;\n// Instantiate DUT\nseven_seg_mux dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .digit0_in(digit0_in),\n    .digit1_in(digit1_in),\n    .seg0_out(seg0_out),\n    .seg1_out(seg1_out),\n    .display_sel(display_sel)\n);\n\n// Clock generation\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;  // 100MHz clock\nend\n\n// Test stimulus\ninitial begin\n    // Initialize\n    rst_n = 0;\n    digit0_in = 4'h0;\n    digit1_in = 4'h0;\n    \n    // Reset release\n    #20 rst_n = 1;\n    \n    // Test different digit combinations\n    #100 digit0_in = 4'h5; digit1_in = 4'hA;\n    #100 digit0_in = 4'h3; digit1_in = 4'h7;\n    #100 digit0_in = 4'h9; digit1_in = 4'hF;\n    \n    // Run for several multiplex cycles\n    #1000000;\n    \n    $finish;\nend\n\n// Monitor outputs\ninitial begin\n    $monitor(\"Time=%0t, mux_sel=%b, digit0=%h, digit1=%h, seg0=%b, seg1=%b, disp_sel=%b\",\n             $time, dut.mux_sel, digit0_in, digit1_in, seg0_out, seg1_out, display_sel);\nend\nendmodule\n\n\nAfter this was created, another prompt was ran through claude: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n// Time Multiplexed Seven Segment Decoder // Uses existing lab2_dg_seg decoder and HSOSC oscillator // Multiplexes between two 4-bit inputs to drive two separate 7-segment outputs\nmodule time_mux_seven_seg ( input logic reset, input logic [3:0] digit0_in, // First 4-bit input input logic [3:0] digit1_in, // Second 4-bit input output logic [6:0] seg0_out, // Seven segments for display 0 output logic [6:0] seg1_out, // Seven segments for display 1 output logic disp0_en, // Display 0 enable (active high) output logic disp1_en // Display 1 enable (active high) );\n// Internal signals\nlogic int_osc;                  // Internal oscillator\nlogic [3:0] mux_input;          // Multiplexed input to decoder\nlogic [6:0] decoder_output;     // Output from seven segment decoder\nlogic enabler;                  // Multiplex control signal\nlogic [20:0] counter;           // Counter for timing\n\n// Internal oscillator instantiation (same as in lab2_dg_top)\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\n// Clock divider and multiplex control (similar to lab2_dg_top)\nalways_ff @(posedge int_osc) begin\n    if (~reset) begin\n        counter &lt;= 21'b0;\n        enabler &lt;= 1'b0;\n    end else begin\n        if (counter == 21'd100000) begin  // Adjust for desired refresh rate\n            enabler &lt;= ~enabler; \n            counter &lt;= 21'b0;\n        end\n        else \n            counter &lt;= counter + 21'd1;\n    end\nend\n\n// Input multiplexer (based on lab2_dg_mux logic)\nalways_comb begin\n    if (enabler == 1'b0) begin\n        disp0_en = 1'b1;\n        disp1_en = 1'b0;\n        mux_input = digit0_in;\n    end\n    else begin\n        disp0_en = 1'b0;\n        disp1_en = 1'b1;\n        mux_input = digit1_in;\n    end \nend\n\n// Instantiate existing seven segment decoder\nlab2_dg_seg u_seg (\n    .mux(mux_input),\n    .seg(decoder_output)\n);\n\n// Output demultiplexer - route decoder output to appropriate display\n// Turn off inactive display (all segments high for common anode)\nalways_comb begin\n    if (enabler == 1'b0) begin\n        seg0_out = decoder_output;\n        seg1_out = 7'b1111111;  // All segments off (common anode)\n    end else begin\n        seg0_out = 7'b1111111;  // All segments off (common anode)\n        seg1_out = decoder_output;\n    end\nend\nendmodule\n// Testbench for the time multiplexed seven segment decoder module time_mux_seven_seg_tb(); logic reset; logic [3:0] digit0_in; logic [3:0] digit1_in; logic [6:0] seg0_out; logic [6:0] seg1_out; logic disp0_en; logic disp1_en; logic [31:0] errors;\n// Instantiate DUT\ntime_mux_seven_seg dut (\n    .reset(reset),\n    .digit0_in(digit0_in),\n    .digit1_in(digit1_in),\n    .seg0_out(seg0_out),\n    .seg1_out(seg1_out),\n    .disp0_en(disp0_en),\n    .disp1_en(disp1_en)\n);\n\n// Test stimulus\ninitial begin\n    errors = 0;\n    \n    // Initialize\n    reset = 0;\n    digit0_in = 4'h0;\n    digit1_in = 4'h0;\n    \n    // Reset release\n    #22 reset = 1;\n    \n    // Test case 1: Display 3 and 2\n    digit0_in = 4'h3;\n    digit1_in = 4'h2;\n    $display(\"Test 1: digit0=3, digit1=2\");\n    \n    // Wait for several multiplex cycles and check outputs\n    repeat(10) begin\n        // Wait for display 0 to be active\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0110000 || seg1_out != 7'b1111111) begin  // 3 on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit 3 failed\");\n        end else begin\n            $display(\"Display 0 correctly showing 3\");\n        end\n        \n        // Wait for display 1 to be active  \n        wait(!disp0_en && disp1_en);\n        #10;\n        if (seg1_out != 7'b0100100 || seg0_out != 7'b1111111) begin  // 2 on display 1\n            errors++;\n            $display(\"Error: Display 1 showing digit 2 failed\");\n        end else begin\n            $display(\"Display 1 correctly showing 2\");\n        end\n    end\n    \n    // Test case 2: Display A and F\n    digit0_in = 4'hA;\n    digit1_in = 4'hF;\n    $display(\"Test 2: digit0=A, digit1=F\");\n    \n    // Wait and check again\n    repeat(5) begin\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0001000) begin  // A on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit A failed\");\n        end else begin\n            $display(\"Display 0 correctly showing A\");\n        end\n        \n        wait(!disp0_en && disp1_en);\n        #10; \n        if (seg1_out != 7'b0001110) begin  // F on display 1\n            errors++;\n            $display(\"Error: Display 1 showing digit F failed\");\n        end else begin\n            $display(\"Display 1 correctly showing F\");\n        end\n    end\n    \n    // Test case 3: Same digits on both displays\n    digit0_in = 4'h8;\n    digit1_in = 4'h8;\n    $display(\"Test 3: Both displays showing 8\");\n    \n    repeat(3) begin\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0000000) begin  // 8 on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit 8 failed\");\n        end\n        \n        wait(!disp0_en && disp1_en);\n        #10;\n        if (seg1_out != 7'b0000000) begin  // 8 on display 1  \n            errors++;\n            $display(\"Error: Display 1 showing digit 8 failed\");\n        end\n    end\n    \n    $display(\"Testbench completed with %0d errors\", errors);\n    if (errors == 0)\n        $display(\"All tests PASSED!\");\n    else\n        $display(\"Some tests FAILED!\");\n        \n    $finish;\nend\n\n// Monitor for debugging\ninitial begin\n    $monitor(\"Time=%0t, reset=%b, enabler=%b, disp0_en=%b, disp1_en=%b, digit0=%h, digit1=%h, seg0=%b, seg1=%b\", \n             $time, reset, dut.enabler, disp0_en, disp1_en, digit0_in, digit1_in, seg0_out, seg1_out);\nend\nendmodule\n\n\nFirst prompt\nThe first prompt centered around ramking our lab but from ai. This prompt centered around time multiplexing for the 7-segment display. Once ran on Radiant, the simulation outputted an error about looping, saying:\nError 35901282 Synthesis ERROR &lt;35901282&gt; - c:/users/drgonzales/e155-lab1-main/fpga/src/lab2/lab2/source/impl_1/aiproto.sv(101): loop count limit exceeded forever never breaks. VERI-1282 [aiproto.sv:101]\nThis error suggests that a loop within the code is looping forever, specifically on line 101. The overall output coming from the Ai, however was correct, it had the right idea of time multiplexing, using the HSOSC from the FPGA, and had correct logic for the mux and 7-segment display.\n\n\nSecond prompt\nThe second prompt had the same idea as the first, however the design files from this lab were also uploaded to compare our .sv files to the code the ai produced. The error that came after synthesis in Radiant was:\nError 1025000 Synthesis ERROR &lt;1025000&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab2/lab2/source/impl_1/aiproto2.vm(26): syntax error near ‘@’\nThis error, however, was confusing in that I did not see a syntax error at this @. This may have been the ai used some sneaky syntaax when c reating the verilog that the synthesis is not used to, but overall the “always_ff @” was used correclty in my opinion. Furthermore, the rest of the code was organized correctly, with correct combinational logic."
  },
  {
    "objectID": "labs/lab7.html#introduction",
    "href": "labs/lab7.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "labs/lab4.html#introduction",
    "href": "labs/lab4.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Lab 0",
    "section": "",
    "text": "Throughout my tenure at Harvey Mudd College I have taken many classes within the engineering discipline. Most of these classes, although cool, had little to do with what I was actually passionate about, which is lithography. Lithography is a process within the chip-making industry, that etches computer chips onto silicon wafers. This process, although existing for many decades, still feels like magic to me, which is the reason I am so passionate about it.\nWithin E155 I would like to further my knowledge of computer engineering and really start grasping how micro-controllers work. Micro-controllers make up the digital world as we know it, and I want to learn how they have a specific impact in Lithography."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1 - A familiarization of Micro-controller units (MCU’s) and field-programmable gate arrays (FPGA’s)\n\n\n\n\n\n\n\n\nSep 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 - Multiplexed 7-segment display\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 - Keypad Scanner\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6 - The Internet of Things and Serial Peripheral Interface\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 - The Advanced Encryption Standard (AES)\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Interrupts\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Digital Audio\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Additional course resources",
    "section": "",
    "text": "Class website: https://hmc-e155.github.io/\nE155 development board schematic: https://hmc-e155.github.io/assets/doc/E155_v4_Dev_Board_BOM.html\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]